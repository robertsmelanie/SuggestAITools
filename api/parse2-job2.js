// A Vercel Serverless Function to parse a job listing using OpenAI's Chat API import OpenAI from 'openai'; // Initialize the OpenAI client with your API key const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY }); export default async function handler(req, res) { if (req.method !== 'POST') { return res.status(405).json({ error: 'Method not allowed' }); } try { const { listing } = req.body; if (!listing) { return res.status(400).json({ error: 'Missing job listing in request body.' }); } // Construct the master prompt const prompt = `You are an expert freelance-advisor assistant. Given the following job listing, extract and return exactly a JSON object with these fields: 1. tasks: An array of concise task strings the freelancer must perform. 2. tools: An array of objects, each with name, benefit, and link. 3. manual_hours: Estimated total hours if done entirely by hand. 4. ai_hours: Estimated total hours if using the above AI tools. 5. market_rate: A suggested $/hr rate based on industry benchmarks (round to nearest dollar). 6. tool_costs: Estimated monthly subscription cost for these tools (round to nearest dollar). Return only valid JSON. Do not include any other text. --- Job Listing: """ ${listing} """`; // Call the OpenAI Chat Completion API const completion = await openai.chat.completions.create({ model: 'gpt-4o-mini', messages: [ { role: 'system', content: 'You are a helpful assistant.' }, { role: 'user', content: prompt } ], temperature: 0.2 }); // Parse the JSON reply const reply = completion.choices[0].message.content; let data; try { data = JSON.parse(reply); } catch (parseErr) { return res.status(500).json({ error: 'Failed to parse JSON from OpenAI response.', response: reply }); } // Return structured JSON to the frontend return res.status(200).json(data); } catch (err) { console.error('Error in parse-job function:', err); return res.status(500).json({ error: 'Internal server error.' }); } } ``` **Usage Notes:** 1. **Environment Variable**: Set `OPENAI_API_KEY` in your Vercel project settings or in a local `.env.local` file. 2. **Frontend Fetch**: In your `analyze()` method, point the fetch to `/api/parse-job`: ```js fetch('/api/parse-job', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ listing: this.jobListing }) }) .then(res => res.json()) .then(data => { this.tasks = data.tasks; this.tools = data.tools; this.manualHours = data.manual_hours; this.aiHours = data.ai_hours; this.marketRate = data.market_rate; this.toolCosts = data.tool_costs; this.calculateRates(); this.scrollTo('tasks'); }); ``` 3. **Error Handling**: If the AI returns invalid JSON, the function replies with the raw text so you can debug. 4. **CORS**: Vercel Functions automatically handle same-origin requests. If you host elsewhere, add CORS headers as needed. This setup ensures your API key stays secure on the serverless backend while the frontend drives the user experience. Feel free to adapt the prompt or error logic as you refine your flows!